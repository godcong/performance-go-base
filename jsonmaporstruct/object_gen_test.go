package jsonmaporstruct

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

//import (
//	"bytes"
//	"testing"
//
//	"github.com/tinylib/msgp/msgp"
//)
//
//func TestMarshalUnmarshalObject(t *testing.T) {
//	v := Object{}
//	bts, err := v.MarshalMsg(nil)
//	if err != nil {
//		t.Fatal(err)
//	}
//	left, err := v.UnmarshalMsg(bts)
//	if err != nil {
//		t.Fatal(err)
//	}
//	if len(left) > 0 {
//		t.Errorf("%d bytes left over after UnmarshalMsg(): %q", len(left), left)
//	}
//
//	left, err = msgp.Skip(bts)
//	if err != nil {
//		t.Fatal(err)
//	}
//	if len(left) > 0 {
//		t.Errorf("%d bytes left over after Skip(): %q", len(left), left)
//	}
//}
//
//func BenchmarkMarshalMsgObject(b *testing.B) {
//	v := Object{}
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		v.MarshalMsg(nil)
//	}
//}
//
//func BenchmarkAppendMsgObject(b *testing.B) {
//	v := Object{}
//	bts := make([]byte, 0, v.Msgsize())
//	bts, _ = v.MarshalMsg(bts[0:0])
//	b.SetBytes(int64(len(bts)))
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		bts, _ = v.MarshalMsg(bts[0:0])
//	}
//}
//
//func BenchmarkUnmarshalObject(b *testing.B) {
//	v := Object{}
//	bts, _ := v.MarshalMsg(nil)
//	b.ReportAllocs()
//	b.SetBytes(int64(len(bts)))
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		_, err := v.UnmarshalMsg(bts)
//		if err != nil {
//			b.Fatal(err)
//		}
//	}
//}
//
//func TestEncodeDecodeObject(t *testing.T) {
//	v := Object{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//
//	m := v.Msgsize()
//	if buf.Len() > m {
//		t.Log("WARNING: TestEncodeDecodeObject Msgsize() is inaccurate")
//	}
//
//	vn := Object{}
//	err := msgp.Decode(&buf, &vn)
//	if err != nil {
//		t.Error(err)
//	}
//
//	buf.Reset()
//	msgp.Encode(&buf, &v)
//	err = msgp.NewReader(&buf).Skip()
//	if err != nil {
//		t.Error(err)
//	}
//}
//
//func BenchmarkEncodeObject(b *testing.B) {
//	v := Object{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//	b.SetBytes(int64(buf.Len()))
//	en := msgp.NewWriter(msgp.Nowhere)
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		v.EncodeMsg(en)
//	}
//	en.Flush()
//}
//
//func BenchmarkDecodeObject(b *testing.B) {
//	v := Object{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//	b.SetBytes(int64(buf.Len()))
//	rd := msgp.NewEndlessReader(buf.Bytes(), b)
//	dc := msgp.NewReader(rd)
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		err := v.DecodeMsg(dc)
//		if err != nil {
//			b.Fatal(err)
//		}
//	}
//}
//
//func TestMarshalUnmarshalObject2(t *testing.T) {
//	v := Object2{}
//	bts, err := v.MarshalMsg(nil)
//	if err != nil {
//		t.Fatal(err)
//	}
//	left, err := v.UnmarshalMsg(bts)
//	if err != nil {
//		t.Fatal(err)
//	}
//	if len(left) > 0 {
//		t.Errorf("%d bytes left over after UnmarshalMsg(): %q", len(left), left)
//	}
//
//	left, err = msgp.Skip(bts)
//	if err != nil {
//		t.Fatal(err)
//	}
//	if len(left) > 0 {
//		t.Errorf("%d bytes left over after Skip(): %q", len(left), left)
//	}
//}
//
//func BenchmarkMarshalMsgObject2(b *testing.B) {
//	v := Object2{}
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		v.MarshalMsg(nil)
//	}
//}
//
//func BenchmarkAppendMsgObject2(b *testing.B) {
//	v := Object2{}
//	bts := make([]byte, 0, v.Msgsize())
//	bts, _ = v.MarshalMsg(bts[0:0])
//	b.SetBytes(int64(len(bts)))
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		bts, _ = v.MarshalMsg(bts[0:0])
//	}
//}
//
//func BenchmarkUnmarshalObject2(b *testing.B) {
//	v := Object2{}
//	bts, _ := v.MarshalMsg(nil)
//	b.ReportAllocs()
//	b.SetBytes(int64(len(bts)))
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		_, err := v.UnmarshalMsg(bts)
//		if err != nil {
//			b.Fatal(err)
//		}
//	}
//}
//
//func TestEncodeDecodeObject2(t *testing.T) {
//	v := Object2{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//
//	m := v.Msgsize()
//	if buf.Len() > m {
//		t.Log("WARNING: TestEncodeDecodeObject2 Msgsize() is inaccurate")
//	}
//
//	vn := Object2{}
//	err := msgp.Decode(&buf, &vn)
//	if err != nil {
//		t.Error(err)
//	}
//
//	buf.Reset()
//	msgp.Encode(&buf, &v)
//	err = msgp.NewReader(&buf).Skip()
//	if err != nil {
//		t.Error(err)
//	}
//}
//
//func BenchmarkEncodeObject2(b *testing.B) {
//	v := Object2{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//	b.SetBytes(int64(buf.Len()))
//	en := msgp.NewWriter(msgp.Nowhere)
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		v.EncodeMsg(en)
//	}
//	en.Flush()
//}
//
//func BenchmarkDecodeObject2(b *testing.B) {
//	v := Object2{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//	b.SetBytes(int64(buf.Len()))
//	rd := msgp.NewEndlessReader(buf.Bytes(), b)
//	dc := msgp.NewReader(rd)
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		err := v.DecodeMsg(dc)
//		if err != nil {
//			b.Fatal(err)
//		}
//	}
//}
//
//func TestMarshalUnmarshalObject3(t *testing.T) {
//	v := Object3{}
//	bts, err := v.MarshalMsg(nil)
//	if err != nil {
//		t.Fatal(err)
//	}
//	left, err := v.UnmarshalMsg(bts)
//	if err != nil {
//		t.Fatal(err)
//	}
//	if len(left) > 0 {
//		t.Errorf("%d bytes left over after UnmarshalMsg(): %q", len(left), left)
//	}
//
//	left, err = msgp.Skip(bts)
//	if err != nil {
//		t.Fatal(err)
//	}
//	if len(left) > 0 {
//		t.Errorf("%d bytes left over after Skip(): %q", len(left), left)
//	}
//}
//
//func BenchmarkMarshalMsgObject3(b *testing.B) {
//	v := Object3{}
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		v.MarshalMsg(nil)
//	}
//}
//
//func BenchmarkAppendMsgObject3(b *testing.B) {
//	v := Object3{}
//	bts := make([]byte, 0, v.Msgsize())
//	bts, _ = v.MarshalMsg(bts[0:0])
//	b.SetBytes(int64(len(bts)))
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		bts, _ = v.MarshalMsg(bts[0:0])
//	}
//}
//
//func BenchmarkUnmarshalObject3(b *testing.B) {
//	v := Object3{}
//	bts, _ := v.MarshalMsg(nil)
//	b.ReportAllocs()
//	b.SetBytes(int64(len(bts)))
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		_, err := v.UnmarshalMsg(bts)
//		if err != nil {
//			b.Fatal(err)
//		}
//	}
//}
//
//func TestEncodeDecodeObject3(t *testing.T) {
//	v := Object3{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//
//	m := v.Msgsize()
//	if buf.Len() > m {
//		t.Log("WARNING: TestEncodeDecodeObject3 Msgsize() is inaccurate")
//	}
//
//	vn := Object3{}
//	err := msgp.Decode(&buf, &vn)
//	if err != nil {
//		t.Error(err)
//	}
//
//	buf.Reset()
//	msgp.Encode(&buf, &v)
//	err = msgp.NewReader(&buf).Skip()
//	if err != nil {
//		t.Error(err)
//	}
//}
//
//func BenchmarkEncodeObject3(b *testing.B) {
//	v := Object3{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//	b.SetBytes(int64(buf.Len()))
//	en := msgp.NewWriter(msgp.Nowhere)
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		v.EncodeMsg(en)
//	}
//	en.Flush()
//}
//
//func BenchmarkDecodeObject3(b *testing.B) {
//	v := Object3{}
//	var buf bytes.Buffer
//	msgp.Encode(&buf, &v)
//	b.SetBytes(int64(buf.Len()))
//	rd := msgp.NewEndlessReader(buf.Bytes(), b)
//	dc := msgp.NewReader(rd)
//	b.ReportAllocs()
//	b.ResetTimer()
//	for i := 0; i < b.N; i++ {
//		err := v.DecodeMsg(dc)
//		if err != nil {
//			b.Fatal(err)
//		}
//	}
//}
